(defpackage defmain
  (:use :cl)
  (:import-from #:net.didierverna.clon
                #:remainder
                #:defsynopsis
                #:make-context
                #:help
                #:getopt)
  (:import-from #:alexandria
                #:ensure-symbol)
  (:import-from #:cl-strings
                #:split
                #:starts-with)
  (:export
   #:defmain
   #:print-help))
(in-package :defmain)

;; For reference on defsynopsys, take a look at it's documentation
;; https://www.lrde.epita.fr/%7Edidier/software/lisp/clon/user/

(defun get-rest-arg (list)
  "Takes a lambda list and returns a symbol, naming &rest argument, or nil."
  (let ((rest-arg-position (position '&rest list)))
    (when rest-arg-position
      (nth (+ rest-arg-position 1)
           list))))


(defun make-synopsis-args (defmain-args)
  "Checks if there is &rest part in defmain's args and outputs it as
\(:postfix \"REPOSITORY\"\) list."

  (let ((rest-arg (get-rest-arg defmain-args)))
    (when rest-arg
      `(:postfix ,(symbol-name rest-arg)))))


(defun make-long-name (symbol)
  (string-downcase (symbol-name symbol)))


(defun make-short-name (symbol)
  (subseq (make-long-name symbol)
          0 1))


(defun make-field-description (name documentation
                               &key
                                 env-var ;; name of environment variable to take value from
                                 flag    ;; if true, then option does not require a value,
                                 ;; but becomes True if specified on the command-line
                                 (default nil default-given-p))
  "Returns a single fields description.
   Name argument is a symbol.
   Function returns a list."

  ;; Type will be choosen from default if it was given,
  ;; or will be a flag or stropt otherwise
  ;; all supported types are described in clon's documentation
  ;; https://www.lrde.epita.fr/%7Edidier/software/lisp/clon/user/Built_002dIn-Valued-Options.html#Built_002dIn-Valued-Options
  (let ((result (list (cond (flag
                             'flag)
                            ((and default-given-p
                                  (typep default 'integer))
                             'lispobj)
                            (t
                             'stropt))
                      :short-name (make-short-name name)
                      :long-name (make-long-name name)
                      :env-var env-var
                      :description documentation)))
    (when default-given-p
      (setf result
            (append result
                    (list :default-value default))))

    result))


(defun add-help-field (args)
  (let ((help-option-already-exists
          (assoc "help" (remove-if-not #'listp args)
                 :test #'string-equal
                 :key (lambda (item)
                        (symbol-name item)))))
    (if help-option-already-exists
        args
        ;; Here we need to intern help symbol into the package expanding
        ;; the macro
        (push (list 'help "Show help on this program." :flag t)
              args))))


(defun map-fields (function defmain-args)
  "Maps given function to all given args. Args should be in the format
   of defmain arguments.

   Returns a list of results from each function call."

  (loop for arg in (add-help-field defmain-args)
        ;; All arguments before any &something key are considered
        ;; as fields descriptions
        when (and (symbolp arg)
                  (char= (elt (symbol-name arg)
                              0)
                         #\&))
          do (return-from map-fields results)
        collect (etypecase arg
                  (symbol (funcall function arg))
                  (list (apply function arg)))
          into results
        finally (return results)))


(defun make-synopsis-fields (defmain-args)
  "Returns fields description for net.didierverna.clon:defsynopsis."
  (map-fields #'make-field-description defmain-args))


(defun get-command-name (symbol)
  (let* ((package (symbol-package symbol))
         (package-name (string-downcase (package-name package)))
         (roswell-prefix "ros.script."))
    (cond ((starts-with package-name
                        roswell-prefix)
           (elt (split package-name ".")
                2))
          ;; If package wasn't generated by Roswell,
          ;; just use symbol's name
          (t (string-downcase (symbol-name symbol))))))


(defun make-binding (name &rest args)
  (declare (ignorable args))
  `(,name (getopt :long-name ,(string-downcase (symbol-name name)))))


(defun make-bindings (defmain-args)
  "Returns a list of forms for \"let\" form.
   Variable args contains a list of arguments given to defmain, like:

   \(\(debug :documentation \"Show traceback instead of short message.\"\)
    \(log   :documentation \"Filename to write log to.\"\)
    &rest repository\)

   For this input, output will be a list like:

   \(\(debug \(net.didierverna.clon:getopt :long-name \"debug\"\)\)
     \(log \(net.didierverna.clon:getopt :long-name \"log\"\)\)\)
"
  (let ((bindings (map-fields #'make-binding defmain-args))
        (rest-arg (get-rest-arg defmain-args)))
    ;; 
    (when rest-arg
      (push `(,rest-arg (remainder))
            bindings))

    bindings))


(defmacro defmain (name (&rest args) &body body)
  (let* ((command-name (get-command-name name))
         (synopsis-args (make-synopsis-args args))
         (synopsis-fields (make-synopsis-fields args))
         (docstring (when (typep (first body)
                                 'string)
                      (prog1 `((text :contents ,(first body)))
                        (setf body (rest body)))))
         (bindings (make-bindings args))
         (help-opt-provided-p (remove-if-not
                               (lambda (binding)
                                 (let ((command (first binding)))
                                   ;; We are searching an option help
                                   (and (string-equal (symbol-name command)
                                                      "help")
                                        ;; And it shouldn't be from the defmain package
                                        (not (eql command
                                                  'help)))))
                               bindings)))
    
    `(progn
       (defsynopsis (,@synopsis-args)
         ,@docstring
         ,@synopsis-fields)
       
       (defun ,name (&rest argv)
         (make-context
          :cmdline (cons ,command-name argv))

         (let (,@bindings)
           ;; Sometimes user may want to redefine a help option
           ;; in this case we shouldn't decide how to print help for him.
           ,(unless help-opt-provided-p
              `(when help
                 (help)
                 (uiop:quit 1)))
  
           ,@body)))))


(defun print-help ()
  "Outputs to stdout a help about command line utility."
  (help))
